# Эмулятор процессора

Эмулятор процессора, поддерживающий: 
- одноадресные инструкции, 
- гарвардскую архитектуру (инструкции отдельно от обрабатываемых данных).

В тестах реализован пример по подсчету суммы элементов массива.

Вдохновлено: https://github.com/khmarbaise/jacem

В указанном репозитории все покруче, я просто сделал под свои требования. 

## Одноадресные инструкции

Под инструкцию выделяется 16 бит:
- 4 бита под код команды (всего 16 возможных команд)
- 2 бита под тип адресации (4 возможных типа адресации)
- 10 бит под адрес (работать можно с памятью объем которой < 1024 ячеек)

## Поддерживаемые типы адресации

### Непосредственная (IMMEDIATE)

Загрузить в аккумулятор константу "30", в команде содержится сам операнд, загрузка его из памяти не требуется.
```
LDA &30
```

### Прямая (DIRECT)

Загрузить в аккумулятор значение из ячейки с адресом 30.
```
LDA ?30
```

### Регистровая (REGISTER)

Загрузить в аккумулятор значение из регистра A. Регистр А - заранее определенный регистр процессора.
```
LDA /A
```

### Косвенно-регистровая (REGISTER_INDIRECT)

Загрузить в аккумулятор слово из ячейки, адрес которой находится в ячейке 30, в команде содержится адрес адреса операнда
```
LDA @30
```

## Команды

| Код  | Байтовое представление | Логика             | Описание                          |
|------|------------------------|--------------------|-----------------------------------|
| LDA  | `0b0000`                 | `AC <- M[AD]`      | Выгрузить значение в аккумулятор  |
| STA  | `0b0001`                 | `M[AD] <- AC`      | Выгрузить из аккумулятора в память |
| ADD  | `0b0010`                 | `AC <- AC + M[AD]` | Сложить                           |
| SUB  | `0b0011`                 | `AC <- AC - M[AD]` | Вычесть                           |
| AND  | `0b0100`                 | `AC <- AC & M[AD]`   | Конъюнкция                        |
| OR   | `0b0101`                 | `AC <- AC * M[AD]`   | Дизъюнкция                         |
| XOR  | `0b0110`                 | `AC <- AC xor M[AD]` | Исключающее ИЛИ                   |
| COM  | `0b0111`                 | `AC <- !M[AD]`       | Обратный код                      |
| CMP  | `0b1000`                 | ---                | Сравнить с аккумулятором          |
| INC  | `0b1001`                 | `AC <- M[AD] + 1`  | Инкремент                         |
| DEC  | `0b1010`                 | `AC <- M[AD] - 1`  | Декремент                         |
| JZ   | `0b1011`                 | `PC <- AD`           | Переход, если ZF != 0             |
| CLEA | `0b1100`                 | `AC <- 0`            | Очистка аккумулятора              |
| INCA | `0b1101`                 | `AC <- AC + 1`       | Инкремент аккумулятора            |
| INP  | `0b1110`                 | `AC <- INPR`         | Ввод                              |
| OUT  | `0b1111`                 | `OUTR <- AC`         | Вывод                             |
